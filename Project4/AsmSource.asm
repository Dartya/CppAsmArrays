.686 ; Директива .686 указывает компилятору ассемблера, что необходимо использовать набор операций процессора определённого поколения.
.MODEL FLAT, C ; Инициализирует модель памяти программы.
; Синтаксис: .MODEL memorymodel [[, langtype]] [[, stackoption]]  
; memorymodel Обязательный параметр, который определяет размер указателей кода и данных. В архитек-туре Win32 используется только одна модель памяти – FLAT
; langtype Необязательный параметр, который задает соглашения именования и вызова процедур и откры-тые символы. В данном примере используются C
.STACK ; При использовании с .MODEL указывает сегмент стека (со СТЕКОМ имя сегментом). Необязатель-ный параметр size указывает число байтов для стека (по умолчанию 1.024).

;Директивы .data, .data?, .const и .code определяют то, что называется секциями. В Win32 нет сегментов, но адресное пространство можно поделить на логические секции. Начало одной секции отмечает конец предыдущей. Есть две группы секций: данных и кода.
;Секция .data содержит инициализированные данные программы.
;Секция .data? содержит неинициализированные данные программы. Иногда нужно только предварительно выделить некоторое количество памяти, не инициализируя её. Эта секция для этого и предназначается. Преимущество неинициализированных данных в том, что они не занимают места в исполняемом файле. Вы всего лишь сообщаете компилятору, сколько места вам понадобится, ко-гда программа загрузится в па-мять.
;Секция .const содержит объявления констант, используемых программой. Константы не могут быть изме-нены. Попытка изменить константу вызывает аварийное завершение программы.
;Задействовать все три секции не обязательно.

.DATA	; секция данных
	helloFormat BYTE "Элемент № %d: %d", 10, 13, 13, 0; шаблонная строка
	mas dd 8d, 23d, -10d, 3d, 4d, -7d, 43d, 56d, 2d, 3d, 45d, 67d, 10d, -5d, -23d ; массив
	n dd 15d	; количество элементов массива mas, далее будет использована как счетчик
	sch dd 0	; для сохранения значения счетчика
	adr dd 0	; для сохранения индекса массива
	num dd 0	; для нумерации элементов массива, удовлетворяющих условию задачи

.CODE ; секция кода
EXTRN  printf : proc ; определение внешней функции вывода форматированной строки

printMas PROC  ; определение процедуры printMas
	; ПОДГОТОВКА ЦИКЛА
	lea edx, mas		; установка регистра данных - загрузка массива
	lea ebx, helloFormat; загрузка в регистры базы подготовленной строки
	mov eax, 0			; обнуление аккумулятора

L:  ; НАЧАЛО ЦИКЛА
	mov eax, [edx]	; перемещаем очередной элемент в аккумулятор
	mov adr, edx	; сохраняем из базы индекс массива в переменной adr

	; БЛОК СРАВНЕНИЯ очередного элемента массива
	cmp eax, 10d	; сравниваем значение в аккумуляторе с 10
	jge L1			; если op1 > op2 - переход по метке
	cmp eax, -10d	; сравниваем значение в аккумуляторе с -10
	jle L1			; если op1 < op2 - переход по метке
	
	; далее выполняется случай TRUE - печать
	inc num			; инкрементируем переменную элементов массива, удовлетворяющих условию задачи
	push eax		; заносим аккумулятор в стек
	push num		; заносим перемунную num в стек
	push ebx		; заносим базу со строкой в стек
	call printf		; вызов функции C++ печати форматированной строки 
	add esp, 12		; освобождаем стек (4 байта * (2 регистра + 1 переменная DD) = 12 байт)

	; БЛОК ПОДГОТОВКИ НОВОЙ ИТЕРАЦИИ ЦИКЛА (установка значений аккумулятора, адреса и счетчика)
	
	mov eax, 0		; обнуление аккумулятора
	add adr, 4		; инкрементируем индекс массива (+4 байта)
	mov edx, adr	; установка регистра данных - загрузка последнего адреса массива
	dec n			; декрементируем значение счетчика
	jmp L2			; переход в блок проверки окончания цикла

L1: ; действия в случае результата FALSE в блоке сравнения
	
	add edx, 4		; инкрементируем индекс массива
	dec n			; декрементируем значение счетчика
	jmp L2			; переход в блок проверки окончания цикла

L2: ; БЛОК ПРОВЕРКИ ОКОНЧАНИЯ ЦИКЛА
	cmp n, 0		; сравнение счетчика с нулем
	jne L			; если не равно - переход на начало цикла

ret					; выход из процедуры

printMas ENDP		; блок окончания процедуры

END